# source: https://us1.prisma.sh/ryan-a5caf5/asset-tracker/dev
# timestamp: Mon Sep 03 2018 16:32:35 GMT-0600 (Mountain Daylight Time)

type AggregateAsset {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateCustomer {
  count: Int!
}

type AggregateDiagnosticNode {
  count: Int!
}

type AggregateDiagnosticProcedure {
  count: Int!
}

type AggregateEquipment {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateNote {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateUserGroup {
  count: Int!
}

type Asset implements Node {
  id: ID!
  serial: String!
  description: String!
  location(where: LocationWhereInput): Location!
  equipment(where: EquipmentWhereInput): Equipment!
  notes(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Note!]
}

"""A connection to a list of items."""
type AssetConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [AssetEdge]!
  aggregate: AggregateAsset!
}

input AssetCreateInput {
  serial: String!
  description: String!
  location: LocationCreateOneWithoutAssetsInput!
  equipment: EquipmentCreateOneWithoutAssetsInput!
  notes: NoteCreateManyInput
}

input AssetCreateManyWithoutEquipmentInput {
  create: [AssetCreateWithoutEquipmentInput!]
  connect: [AssetWhereUniqueInput!]
}

input AssetCreateManyWithoutLocationInput {
  create: [AssetCreateWithoutLocationInput!]
  connect: [AssetWhereUniqueInput!]
}

input AssetCreateWithoutEquipmentInput {
  serial: String!
  description: String!
  location: LocationCreateOneWithoutAssetsInput!
  notes: NoteCreateManyInput
}

input AssetCreateWithoutLocationInput {
  serial: String!
  description: String!
  equipment: EquipmentCreateOneWithoutAssetsInput!
  notes: NoteCreateManyInput
}

"""An edge in a connection."""
type AssetEdge {
  """The item at the end of the edge."""
  node: Asset!

  """A cursor for use in pagination."""
  cursor: String!
}

enum AssetOrderByInput {
  id_ASC
  id_DESC
  serial_ASC
  serial_DESC
  description_ASC
  description_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type AssetPreviousValues {
  id: ID!
  serial: String!
  description: String!
}

type AssetSubscriptionPayload {
  mutation: MutationType!
  node: Asset
  updatedFields: [String!]
  previousValues: AssetPreviousValues
}

input AssetSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [AssetSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [AssetSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AssetSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: AssetWhereInput
}

input AssetUpdateInput {
  serial: String
  description: String
  location: LocationUpdateOneWithoutAssetsInput
  equipment: EquipmentUpdateOneWithoutAssetsInput
  notes: NoteUpdateManyInput
}

input AssetUpdateManyWithoutEquipmentInput {
  create: [AssetCreateWithoutEquipmentInput!]
  connect: [AssetWhereUniqueInput!]
  disconnect: [AssetWhereUniqueInput!]
  delete: [AssetWhereUniqueInput!]
  update: [AssetUpdateWithWhereUniqueWithoutEquipmentInput!]
  upsert: [AssetUpsertWithWhereUniqueWithoutEquipmentInput!]
}

input AssetUpdateManyWithoutLocationInput {
  create: [AssetCreateWithoutLocationInput!]
  connect: [AssetWhereUniqueInput!]
  disconnect: [AssetWhereUniqueInput!]
  delete: [AssetWhereUniqueInput!]
  update: [AssetUpdateWithWhereUniqueWithoutLocationInput!]
  upsert: [AssetUpsertWithWhereUniqueWithoutLocationInput!]
}

input AssetUpdateWithoutEquipmentDataInput {
  serial: String
  description: String
  location: LocationUpdateOneWithoutAssetsInput
  notes: NoteUpdateManyInput
}

input AssetUpdateWithoutLocationDataInput {
  serial: String
  description: String
  equipment: EquipmentUpdateOneWithoutAssetsInput
  notes: NoteUpdateManyInput
}

input AssetUpdateWithWhereUniqueWithoutEquipmentInput {
  where: AssetWhereUniqueInput!
  data: AssetUpdateWithoutEquipmentDataInput!
}

input AssetUpdateWithWhereUniqueWithoutLocationInput {
  where: AssetWhereUniqueInput!
  data: AssetUpdateWithoutLocationDataInput!
}

input AssetUpsertWithWhereUniqueWithoutEquipmentInput {
  where: AssetWhereUniqueInput!
  update: AssetUpdateWithoutEquipmentDataInput!
  create: AssetCreateWithoutEquipmentInput!
}

input AssetUpsertWithWhereUniqueWithoutLocationInput {
  where: AssetWhereUniqueInput!
  update: AssetUpdateWithoutLocationDataInput!
  create: AssetCreateWithoutLocationInput!
}

input AssetWhereInput {
  """Logical AND on all given filters."""
  AND: [AssetWhereInput!]

  """Logical OR on all given filters."""
  OR: [AssetWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [AssetWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  serial: String

  """All values that are not equal to given value."""
  serial_not: String

  """All values that are contained in given list."""
  serial_in: [String!]

  """All values that are not contained in given list."""
  serial_not_in: [String!]

  """All values less than the given value."""
  serial_lt: String

  """All values less than or equal the given value."""
  serial_lte: String

  """All values greater than the given value."""
  serial_gt: String

  """All values greater than or equal the given value."""
  serial_gte: String

  """All values containing the given string."""
  serial_contains: String

  """All values not containing the given string."""
  serial_not_contains: String

  """All values starting with the given string."""
  serial_starts_with: String

  """All values not starting with the given string."""
  serial_not_starts_with: String

  """All values ending with the given string."""
  serial_ends_with: String

  """All values not ending with the given string."""
  serial_not_ends_with: String
  description: String

  """All values that are not equal to given value."""
  description_not: String

  """All values that are contained in given list."""
  description_in: [String!]

  """All values that are not contained in given list."""
  description_not_in: [String!]

  """All values less than the given value."""
  description_lt: String

  """All values less than or equal the given value."""
  description_lte: String

  """All values greater than the given value."""
  description_gt: String

  """All values greater than or equal the given value."""
  description_gte: String

  """All values containing the given string."""
  description_contains: String

  """All values not containing the given string."""
  description_not_contains: String

  """All values starting with the given string."""
  description_starts_with: String

  """All values not starting with the given string."""
  description_not_starts_with: String

  """All values ending with the given string."""
  description_ends_with: String

  """All values not ending with the given string."""
  description_not_ends_with: String
  location: LocationWhereInput
  equipment: EquipmentWhereInput
  notes_every: NoteWhereInput
  notes_some: NoteWhereInput
  notes_none: NoteWhereInput
}

input AssetWhereUniqueInput {
  id: ID
}

type BatchPayload {
  """The number of nodes that have been affected by the Batch operation."""
  count: Long!
}

type Category implements Node {
  id: ID!
  name: String!
  description: String!
  equipment(where: EquipmentWhereInput, orderBy: EquipmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Equipment!]
  diagnostics(where: DiagnosticProcedureWhereInput, orderBy: DiagnosticProcedureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DiagnosticProcedure!]
  group(where: UserGroupWhereInput): UserGroup!
}

"""A connection to a list of items."""
type CategoryConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  name: String!
  description: String!
  equipment: EquipmentCreateManyWithoutCategoryInput
  diagnostics: DiagnosticProcedureCreateManyWithoutCategoryInput
  group: UserGroupCreateOneWithoutCategoriesInput!
}

input CategoryCreateManyWithoutGroupInput {
  create: [CategoryCreateWithoutGroupInput!]
  connect: [CategoryWhereUniqueInput!]
}

input CategoryCreateOneWithoutDiagnosticsInput {
  create: CategoryCreateWithoutDiagnosticsInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateOneWithoutEquipmentInput {
  create: CategoryCreateWithoutEquipmentInput
  connect: CategoryWhereUniqueInput
}

input CategoryCreateWithoutDiagnosticsInput {
  name: String!
  description: String!
  equipment: EquipmentCreateManyWithoutCategoryInput
  group: UserGroupCreateOneWithoutCategoriesInput!
}

input CategoryCreateWithoutEquipmentInput {
  name: String!
  description: String!
  diagnostics: DiagnosticProcedureCreateManyWithoutCategoryInput
  group: UserGroupCreateOneWithoutCategoriesInput!
}

input CategoryCreateWithoutGroupInput {
  name: String!
  description: String!
  equipment: EquipmentCreateManyWithoutCategoryInput
  diagnostics: DiagnosticProcedureCreateManyWithoutCategoryInput
}

"""An edge in a connection."""
type CategoryEdge {
  """The item at the end of the edge."""
  node: Category!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CategoryPreviousValues {
  id: ID!
  name: String!
  description: String!
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CategorySubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CategorySubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CategorySubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
}

input CategoryUpdateInput {
  name: String
  description: String
  equipment: EquipmentUpdateManyWithoutCategoryInput
  diagnostics: DiagnosticProcedureUpdateManyWithoutCategoryInput
  group: UserGroupUpdateOneWithoutCategoriesInput
}

input CategoryUpdateManyWithoutGroupInput {
  create: [CategoryCreateWithoutGroupInput!]
  connect: [CategoryWhereUniqueInput!]
  disconnect: [CategoryWhereUniqueInput!]
  delete: [CategoryWhereUniqueInput!]
  update: [CategoryUpdateWithWhereUniqueWithoutGroupInput!]
  upsert: [CategoryUpsertWithWhereUniqueWithoutGroupInput!]
}

input CategoryUpdateOneWithoutDiagnosticsInput {
  create: CategoryCreateWithoutDiagnosticsInput
  connect: CategoryWhereUniqueInput
  delete: Boolean
  update: CategoryUpdateWithoutDiagnosticsDataInput
  upsert: CategoryUpsertWithoutDiagnosticsInput
}

input CategoryUpdateOneWithoutEquipmentInput {
  create: CategoryCreateWithoutEquipmentInput
  connect: CategoryWhereUniqueInput
  delete: Boolean
  update: CategoryUpdateWithoutEquipmentDataInput
  upsert: CategoryUpsertWithoutEquipmentInput
}

input CategoryUpdateWithoutDiagnosticsDataInput {
  name: String
  description: String
  equipment: EquipmentUpdateManyWithoutCategoryInput
  group: UserGroupUpdateOneWithoutCategoriesInput
}

input CategoryUpdateWithoutEquipmentDataInput {
  name: String
  description: String
  diagnostics: DiagnosticProcedureUpdateManyWithoutCategoryInput
  group: UserGroupUpdateOneWithoutCategoriesInput
}

input CategoryUpdateWithoutGroupDataInput {
  name: String
  description: String
  equipment: EquipmentUpdateManyWithoutCategoryInput
  diagnostics: DiagnosticProcedureUpdateManyWithoutCategoryInput
}

input CategoryUpdateWithWhereUniqueWithoutGroupInput {
  where: CategoryWhereUniqueInput!
  data: CategoryUpdateWithoutGroupDataInput!
}

input CategoryUpsertWithoutDiagnosticsInput {
  update: CategoryUpdateWithoutDiagnosticsDataInput!
  create: CategoryCreateWithoutDiagnosticsInput!
}

input CategoryUpsertWithoutEquipmentInput {
  update: CategoryUpdateWithoutEquipmentDataInput!
  create: CategoryCreateWithoutEquipmentInput!
}

input CategoryUpsertWithWhereUniqueWithoutGroupInput {
  where: CategoryWhereUniqueInput!
  update: CategoryUpdateWithoutGroupDataInput!
  create: CategoryCreateWithoutGroupInput!
}

input CategoryWhereInput {
  """Logical AND on all given filters."""
  AND: [CategoryWhereInput!]

  """Logical OR on all given filters."""
  OR: [CategoryWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CategoryWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  description: String

  """All values that are not equal to given value."""
  description_not: String

  """All values that are contained in given list."""
  description_in: [String!]

  """All values that are not contained in given list."""
  description_not_in: [String!]

  """All values less than the given value."""
  description_lt: String

  """All values less than or equal the given value."""
  description_lte: String

  """All values greater than the given value."""
  description_gt: String

  """All values greater than or equal the given value."""
  description_gte: String

  """All values containing the given string."""
  description_contains: String

  """All values not containing the given string."""
  description_not_contains: String

  """All values starting with the given string."""
  description_starts_with: String

  """All values not starting with the given string."""
  description_not_starts_with: String

  """All values ending with the given string."""
  description_ends_with: String

  """All values not ending with the given string."""
  description_not_ends_with: String
  equipment_every: EquipmentWhereInput
  equipment_some: EquipmentWhereInput
  equipment_none: EquipmentWhereInput
  diagnostics_every: DiagnosticProcedureWhereInput
  diagnostics_some: DiagnosticProcedureWhereInput
  diagnostics_none: DiagnosticProcedureWhereInput
  group: UserGroupWhereInput
}

input CategoryWhereUniqueInput {
  id: ID
}

type Customer implements Node {
  id: ID!
  name: String!
  notes(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Note!]
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location!]
  group(where: UserGroupWhereInput): UserGroup!
}

"""A connection to a list of items."""
type CustomerConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CustomerEdge]!
  aggregate: AggregateCustomer!
}

input CustomerCreateInput {
  name: String!
  notes: NoteCreateManyInput
  locations: LocationCreateManyWithoutCustomerInput
  group: UserGroupCreateOneWithoutCustomersInput!
}

input CustomerCreateManyWithoutGroupInput {
  create: [CustomerCreateWithoutGroupInput!]
  connect: [CustomerWhereUniqueInput!]
}

input CustomerCreateOneWithoutLocationsInput {
  create: CustomerCreateWithoutLocationsInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateWithoutGroupInput {
  name: String!
  notes: NoteCreateManyInput
  locations: LocationCreateManyWithoutCustomerInput
}

input CustomerCreateWithoutLocationsInput {
  name: String!
  notes: NoteCreateManyInput
  group: UserGroupCreateOneWithoutCustomersInput!
}

"""An edge in a connection."""
type CustomerEdge {
  """The item at the end of the edge."""
  node: Customer!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CustomerOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CustomerPreviousValues {
  id: ID!
  name: String!
}

type CustomerSubscriptionPayload {
  mutation: MutationType!
  node: Customer
  updatedFields: [String!]
  previousValues: CustomerPreviousValues
}

input CustomerSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CustomerSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CustomerSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CustomerSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CustomerWhereInput
}

input CustomerUpdateInput {
  name: String
  notes: NoteUpdateManyInput
  locations: LocationUpdateManyWithoutCustomerInput
  group: UserGroupUpdateOneWithoutCustomersInput
}

input CustomerUpdateManyWithoutGroupInput {
  create: [CustomerCreateWithoutGroupInput!]
  connect: [CustomerWhereUniqueInput!]
  disconnect: [CustomerWhereUniqueInput!]
  delete: [CustomerWhereUniqueInput!]
  update: [CustomerUpdateWithWhereUniqueWithoutGroupInput!]
  upsert: [CustomerUpsertWithWhereUniqueWithoutGroupInput!]
}

input CustomerUpdateOneWithoutLocationsInput {
  create: CustomerCreateWithoutLocationsInput
  connect: CustomerWhereUniqueInput
  delete: Boolean
  update: CustomerUpdateWithoutLocationsDataInput
  upsert: CustomerUpsertWithoutLocationsInput
}

input CustomerUpdateWithoutGroupDataInput {
  name: String
  notes: NoteUpdateManyInput
  locations: LocationUpdateManyWithoutCustomerInput
}

input CustomerUpdateWithoutLocationsDataInput {
  name: String
  notes: NoteUpdateManyInput
  group: UserGroupUpdateOneWithoutCustomersInput
}

input CustomerUpdateWithWhereUniqueWithoutGroupInput {
  where: CustomerWhereUniqueInput!
  data: CustomerUpdateWithoutGroupDataInput!
}

input CustomerUpsertWithoutLocationsInput {
  update: CustomerUpdateWithoutLocationsDataInput!
  create: CustomerCreateWithoutLocationsInput!
}

input CustomerUpsertWithWhereUniqueWithoutGroupInput {
  where: CustomerWhereUniqueInput!
  update: CustomerUpdateWithoutGroupDataInput!
  create: CustomerCreateWithoutGroupInput!
}

input CustomerWhereInput {
  """Logical AND on all given filters."""
  AND: [CustomerWhereInput!]

  """Logical OR on all given filters."""
  OR: [CustomerWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CustomerWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  notes_every: NoteWhereInput
  notes_some: NoteWhereInput
  notes_none: NoteWhereInput
  locations_every: LocationWhereInput
  locations_some: LocationWhereInput
  locations_none: LocationWhereInput
  group: UserGroupWhereInput
}

input CustomerWhereUniqueInput {
  id: ID
}

scalar DateTime

type DiagnosticNode implements Node {
  id: ID!
  procedure(where: DiagnosticProcedureWhereInput): DiagnosticProcedure!
  answerNodes(where: DiagnosticNodeWhereInput, orderBy: DiagnosticNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DiagnosticNode!]
  answer: String!
  content: String!
  resolution: Boolean!
}

"""A connection to a list of items."""
type DiagnosticNodeConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [DiagnosticNodeEdge]!
  aggregate: AggregateDiagnosticNode!
}

input DiagnosticNodeCreateInput {
  answer: String!
  content: String!
  resolution: Boolean
  procedure: DiagnosticProcedureCreateOneWithoutStartNodeInput!
  answerNodes: DiagnosticNodeCreateManyInput
}

input DiagnosticNodeCreateManyInput {
  create: [DiagnosticNodeCreateInput!]
  connect: [DiagnosticNodeWhereUniqueInput!]
}

input DiagnosticNodeCreateOneWithoutProcedureInput {
  create: DiagnosticNodeCreateWithoutProcedureInput
  connect: DiagnosticNodeWhereUniqueInput
}

input DiagnosticNodeCreateWithoutProcedureInput {
  answer: String!
  content: String!
  resolution: Boolean
  answerNodes: DiagnosticNodeCreateManyInput
}

"""An edge in a connection."""
type DiagnosticNodeEdge {
  """The item at the end of the edge."""
  node: DiagnosticNode!

  """A cursor for use in pagination."""
  cursor: String!
}

enum DiagnosticNodeOrderByInput {
  id_ASC
  id_DESC
  answer_ASC
  answer_DESC
  content_ASC
  content_DESC
  resolution_ASC
  resolution_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type DiagnosticNodePreviousValues {
  id: ID!
  answer: String!
  content: String!
  resolution: Boolean!
}

type DiagnosticNodeSubscriptionPayload {
  mutation: MutationType!
  node: DiagnosticNode
  updatedFields: [String!]
  previousValues: DiagnosticNodePreviousValues
}

input DiagnosticNodeSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [DiagnosticNodeSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [DiagnosticNodeSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [DiagnosticNodeSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: DiagnosticNodeWhereInput
}

input DiagnosticNodeUpdateDataInput {
  answer: String
  content: String
  resolution: Boolean
  procedure: DiagnosticProcedureUpdateOneWithoutStartNodeInput
  answerNodes: DiagnosticNodeUpdateManyInput
}

input DiagnosticNodeUpdateInput {
  answer: String
  content: String
  resolution: Boolean
  procedure: DiagnosticProcedureUpdateOneWithoutStartNodeInput
  answerNodes: DiagnosticNodeUpdateManyInput
}

input DiagnosticNodeUpdateManyInput {
  create: [DiagnosticNodeCreateInput!]
  connect: [DiagnosticNodeWhereUniqueInput!]
  disconnect: [DiagnosticNodeWhereUniqueInput!]
  delete: [DiagnosticNodeWhereUniqueInput!]
  update: [DiagnosticNodeUpdateWithWhereUniqueNestedInput!]
  upsert: [DiagnosticNodeUpsertWithWhereUniqueNestedInput!]
}

input DiagnosticNodeUpdateOneWithoutProcedureInput {
  create: DiagnosticNodeCreateWithoutProcedureInput
  connect: DiagnosticNodeWhereUniqueInput
  delete: Boolean
  update: DiagnosticNodeUpdateWithoutProcedureDataInput
  upsert: DiagnosticNodeUpsertWithoutProcedureInput
}

input DiagnosticNodeUpdateWithoutProcedureDataInput {
  answer: String
  content: String
  resolution: Boolean
  answerNodes: DiagnosticNodeUpdateManyInput
}

input DiagnosticNodeUpdateWithWhereUniqueNestedInput {
  where: DiagnosticNodeWhereUniqueInput!
  data: DiagnosticNodeUpdateDataInput!
}

input DiagnosticNodeUpsertWithoutProcedureInput {
  update: DiagnosticNodeUpdateWithoutProcedureDataInput!
  create: DiagnosticNodeCreateWithoutProcedureInput!
}

input DiagnosticNodeUpsertWithWhereUniqueNestedInput {
  where: DiagnosticNodeWhereUniqueInput!
  update: DiagnosticNodeUpdateDataInput!
  create: DiagnosticNodeCreateInput!
}

input DiagnosticNodeWhereInput {
  """Logical AND on all given filters."""
  AND: [DiagnosticNodeWhereInput!]

  """Logical OR on all given filters."""
  OR: [DiagnosticNodeWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [DiagnosticNodeWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  answer: String

  """All values that are not equal to given value."""
  answer_not: String

  """All values that are contained in given list."""
  answer_in: [String!]

  """All values that are not contained in given list."""
  answer_not_in: [String!]

  """All values less than the given value."""
  answer_lt: String

  """All values less than or equal the given value."""
  answer_lte: String

  """All values greater than the given value."""
  answer_gt: String

  """All values greater than or equal the given value."""
  answer_gte: String

  """All values containing the given string."""
  answer_contains: String

  """All values not containing the given string."""
  answer_not_contains: String

  """All values starting with the given string."""
  answer_starts_with: String

  """All values not starting with the given string."""
  answer_not_starts_with: String

  """All values ending with the given string."""
  answer_ends_with: String

  """All values not ending with the given string."""
  answer_not_ends_with: String
  content: String

  """All values that are not equal to given value."""
  content_not: String

  """All values that are contained in given list."""
  content_in: [String!]

  """All values that are not contained in given list."""
  content_not_in: [String!]

  """All values less than the given value."""
  content_lt: String

  """All values less than or equal the given value."""
  content_lte: String

  """All values greater than the given value."""
  content_gt: String

  """All values greater than or equal the given value."""
  content_gte: String

  """All values containing the given string."""
  content_contains: String

  """All values not containing the given string."""
  content_not_contains: String

  """All values starting with the given string."""
  content_starts_with: String

  """All values not starting with the given string."""
  content_not_starts_with: String

  """All values ending with the given string."""
  content_ends_with: String

  """All values not ending with the given string."""
  content_not_ends_with: String
  resolution: Boolean

  """All values that are not equal to given value."""
  resolution_not: Boolean
  procedure: DiagnosticProcedureWhereInput
  answerNodes_every: DiagnosticNodeWhereInput
  answerNodes_some: DiagnosticNodeWhereInput
  answerNodes_none: DiagnosticNodeWhereInput
}

input DiagnosticNodeWhereUniqueInput {
  id: ID
}

type DiagnosticProcedure implements Node {
  id: ID!
  createdBy(where: UserWhereInput): User!
  category(where: CategoryWhereInput): Category!
  equipment(where: EquipmentWhereInput): Equipment
  description: String
  name: String!
  startNode(where: DiagnosticNodeWhereInput): DiagnosticNode!
}

"""A connection to a list of items."""
type DiagnosticProcedureConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [DiagnosticProcedureEdge]!
  aggregate: AggregateDiagnosticProcedure!
}

input DiagnosticProcedureCreateInput {
  description: String
  name: String!
  createdBy: UserCreateOneInput!
  category: CategoryCreateOneWithoutDiagnosticsInput!
  equipment: EquipmentCreateOneWithoutDiagnosticsInput
  startNode: DiagnosticNodeCreateOneWithoutProcedureInput!
}

input DiagnosticProcedureCreateManyWithoutCategoryInput {
  create: [DiagnosticProcedureCreateWithoutCategoryInput!]
  connect: [DiagnosticProcedureWhereUniqueInput!]
}

input DiagnosticProcedureCreateManyWithoutEquipmentInput {
  create: [DiagnosticProcedureCreateWithoutEquipmentInput!]
  connect: [DiagnosticProcedureWhereUniqueInput!]
}

input DiagnosticProcedureCreateOneWithoutStartNodeInput {
  create: DiagnosticProcedureCreateWithoutStartNodeInput
  connect: DiagnosticProcedureWhereUniqueInput
}

input DiagnosticProcedureCreateWithoutCategoryInput {
  description: String
  name: String!
  createdBy: UserCreateOneInput!
  equipment: EquipmentCreateOneWithoutDiagnosticsInput
  startNode: DiagnosticNodeCreateOneWithoutProcedureInput!
}

input DiagnosticProcedureCreateWithoutEquipmentInput {
  description: String
  name: String!
  createdBy: UserCreateOneInput!
  category: CategoryCreateOneWithoutDiagnosticsInput!
  startNode: DiagnosticNodeCreateOneWithoutProcedureInput!
}

input DiagnosticProcedureCreateWithoutStartNodeInput {
  description: String
  name: String!
  createdBy: UserCreateOneInput!
  category: CategoryCreateOneWithoutDiagnosticsInput!
  equipment: EquipmentCreateOneWithoutDiagnosticsInput
}

"""An edge in a connection."""
type DiagnosticProcedureEdge {
  """The item at the end of the edge."""
  node: DiagnosticProcedure!

  """A cursor for use in pagination."""
  cursor: String!
}

enum DiagnosticProcedureOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type DiagnosticProcedurePreviousValues {
  id: ID!
  description: String
  name: String!
}

type DiagnosticProcedureSubscriptionPayload {
  mutation: MutationType!
  node: DiagnosticProcedure
  updatedFields: [String!]
  previousValues: DiagnosticProcedurePreviousValues
}

input DiagnosticProcedureSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [DiagnosticProcedureSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [DiagnosticProcedureSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [DiagnosticProcedureSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: DiagnosticProcedureWhereInput
}

input DiagnosticProcedureUpdateInput {
  description: String
  name: String
  createdBy: UserUpdateOneInput
  category: CategoryUpdateOneWithoutDiagnosticsInput
  equipment: EquipmentUpdateOneWithoutDiagnosticsInput
  startNode: DiagnosticNodeUpdateOneWithoutProcedureInput
}

input DiagnosticProcedureUpdateManyWithoutCategoryInput {
  create: [DiagnosticProcedureCreateWithoutCategoryInput!]
  connect: [DiagnosticProcedureWhereUniqueInput!]
  disconnect: [DiagnosticProcedureWhereUniqueInput!]
  delete: [DiagnosticProcedureWhereUniqueInput!]
  update: [DiagnosticProcedureUpdateWithWhereUniqueWithoutCategoryInput!]
  upsert: [DiagnosticProcedureUpsertWithWhereUniqueWithoutCategoryInput!]
}

input DiagnosticProcedureUpdateManyWithoutEquipmentInput {
  create: [DiagnosticProcedureCreateWithoutEquipmentInput!]
  connect: [DiagnosticProcedureWhereUniqueInput!]
  disconnect: [DiagnosticProcedureWhereUniqueInput!]
  delete: [DiagnosticProcedureWhereUniqueInput!]
  update: [DiagnosticProcedureUpdateWithWhereUniqueWithoutEquipmentInput!]
  upsert: [DiagnosticProcedureUpsertWithWhereUniqueWithoutEquipmentInput!]
}

input DiagnosticProcedureUpdateOneWithoutStartNodeInput {
  create: DiagnosticProcedureCreateWithoutStartNodeInput
  connect: DiagnosticProcedureWhereUniqueInput
  delete: Boolean
  update: DiagnosticProcedureUpdateWithoutStartNodeDataInput
  upsert: DiagnosticProcedureUpsertWithoutStartNodeInput
}

input DiagnosticProcedureUpdateWithoutCategoryDataInput {
  description: String
  name: String
  createdBy: UserUpdateOneInput
  equipment: EquipmentUpdateOneWithoutDiagnosticsInput
  startNode: DiagnosticNodeUpdateOneWithoutProcedureInput
}

input DiagnosticProcedureUpdateWithoutEquipmentDataInput {
  description: String
  name: String
  createdBy: UserUpdateOneInput
  category: CategoryUpdateOneWithoutDiagnosticsInput
  startNode: DiagnosticNodeUpdateOneWithoutProcedureInput
}

input DiagnosticProcedureUpdateWithoutStartNodeDataInput {
  description: String
  name: String
  createdBy: UserUpdateOneInput
  category: CategoryUpdateOneWithoutDiagnosticsInput
  equipment: EquipmentUpdateOneWithoutDiagnosticsInput
}

input DiagnosticProcedureUpdateWithWhereUniqueWithoutCategoryInput {
  where: DiagnosticProcedureWhereUniqueInput!
  data: DiagnosticProcedureUpdateWithoutCategoryDataInput!
}

input DiagnosticProcedureUpdateWithWhereUniqueWithoutEquipmentInput {
  where: DiagnosticProcedureWhereUniqueInput!
  data: DiagnosticProcedureUpdateWithoutEquipmentDataInput!
}

input DiagnosticProcedureUpsertWithoutStartNodeInput {
  update: DiagnosticProcedureUpdateWithoutStartNodeDataInput!
  create: DiagnosticProcedureCreateWithoutStartNodeInput!
}

input DiagnosticProcedureUpsertWithWhereUniqueWithoutCategoryInput {
  where: DiagnosticProcedureWhereUniqueInput!
  update: DiagnosticProcedureUpdateWithoutCategoryDataInput!
  create: DiagnosticProcedureCreateWithoutCategoryInput!
}

input DiagnosticProcedureUpsertWithWhereUniqueWithoutEquipmentInput {
  where: DiagnosticProcedureWhereUniqueInput!
  update: DiagnosticProcedureUpdateWithoutEquipmentDataInput!
  create: DiagnosticProcedureCreateWithoutEquipmentInput!
}

input DiagnosticProcedureWhereInput {
  """Logical AND on all given filters."""
  AND: [DiagnosticProcedureWhereInput!]

  """Logical OR on all given filters."""
  OR: [DiagnosticProcedureWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [DiagnosticProcedureWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  description: String

  """All values that are not equal to given value."""
  description_not: String

  """All values that are contained in given list."""
  description_in: [String!]

  """All values that are not contained in given list."""
  description_not_in: [String!]

  """All values less than the given value."""
  description_lt: String

  """All values less than or equal the given value."""
  description_lte: String

  """All values greater than the given value."""
  description_gt: String

  """All values greater than or equal the given value."""
  description_gte: String

  """All values containing the given string."""
  description_contains: String

  """All values not containing the given string."""
  description_not_contains: String

  """All values starting with the given string."""
  description_starts_with: String

  """All values not starting with the given string."""
  description_not_starts_with: String

  """All values ending with the given string."""
  description_ends_with: String

  """All values not ending with the given string."""
  description_not_ends_with: String
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  createdBy: UserWhereInput
  category: CategoryWhereInput
  equipment: EquipmentWhereInput
  startNode: DiagnosticNodeWhereInput
}

input DiagnosticProcedureWhereUniqueInput {
  id: ID
}

type Equipment implements Node {
  id: ID!
  name: String!
  description: String!
  model: String!
  category(where: CategoryWhereInput): Category!
  diagnostics(where: DiagnosticProcedureWhereInput, orderBy: DiagnosticProcedureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DiagnosticProcedure!]
  assets(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Asset!]
}

"""A connection to a list of items."""
type EquipmentConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [EquipmentEdge]!
  aggregate: AggregateEquipment!
}

input EquipmentCreateInput {
  name: String!
  description: String!
  model: String!
  category: CategoryCreateOneWithoutEquipmentInput!
  diagnostics: DiagnosticProcedureCreateManyWithoutEquipmentInput
  assets: AssetCreateManyWithoutEquipmentInput
}

input EquipmentCreateManyWithoutCategoryInput {
  create: [EquipmentCreateWithoutCategoryInput!]
  connect: [EquipmentWhereUniqueInput!]
}

input EquipmentCreateOneWithoutAssetsInput {
  create: EquipmentCreateWithoutAssetsInput
  connect: EquipmentWhereUniqueInput
}

input EquipmentCreateOneWithoutDiagnosticsInput {
  create: EquipmentCreateWithoutDiagnosticsInput
  connect: EquipmentWhereUniqueInput
}

input EquipmentCreateWithoutAssetsInput {
  name: String!
  description: String!
  model: String!
  category: CategoryCreateOneWithoutEquipmentInput!
  diagnostics: DiagnosticProcedureCreateManyWithoutEquipmentInput
}

input EquipmentCreateWithoutCategoryInput {
  name: String!
  description: String!
  model: String!
  diagnostics: DiagnosticProcedureCreateManyWithoutEquipmentInput
  assets: AssetCreateManyWithoutEquipmentInput
}

input EquipmentCreateWithoutDiagnosticsInput {
  name: String!
  description: String!
  model: String!
  category: CategoryCreateOneWithoutEquipmentInput!
  assets: AssetCreateManyWithoutEquipmentInput
}

"""An edge in a connection."""
type EquipmentEdge {
  """The item at the end of the edge."""
  node: Equipment!

  """A cursor for use in pagination."""
  cursor: String!
}

enum EquipmentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  model_ASC
  model_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type EquipmentPreviousValues {
  id: ID!
  name: String!
  description: String!
  model: String!
}

type EquipmentSubscriptionPayload {
  mutation: MutationType!
  node: Equipment
  updatedFields: [String!]
  previousValues: EquipmentPreviousValues
}

input EquipmentSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [EquipmentSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [EquipmentSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [EquipmentSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: EquipmentWhereInput
}

input EquipmentUpdateInput {
  name: String
  description: String
  model: String
  category: CategoryUpdateOneWithoutEquipmentInput
  diagnostics: DiagnosticProcedureUpdateManyWithoutEquipmentInput
  assets: AssetUpdateManyWithoutEquipmentInput
}

input EquipmentUpdateManyWithoutCategoryInput {
  create: [EquipmentCreateWithoutCategoryInput!]
  connect: [EquipmentWhereUniqueInput!]
  disconnect: [EquipmentWhereUniqueInput!]
  delete: [EquipmentWhereUniqueInput!]
  update: [EquipmentUpdateWithWhereUniqueWithoutCategoryInput!]
  upsert: [EquipmentUpsertWithWhereUniqueWithoutCategoryInput!]
}

input EquipmentUpdateOneWithoutAssetsInput {
  create: EquipmentCreateWithoutAssetsInput
  connect: EquipmentWhereUniqueInput
  delete: Boolean
  update: EquipmentUpdateWithoutAssetsDataInput
  upsert: EquipmentUpsertWithoutAssetsInput
}

input EquipmentUpdateOneWithoutDiagnosticsInput {
  create: EquipmentCreateWithoutDiagnosticsInput
  connect: EquipmentWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: EquipmentUpdateWithoutDiagnosticsDataInput
  upsert: EquipmentUpsertWithoutDiagnosticsInput
}

input EquipmentUpdateWithoutAssetsDataInput {
  name: String
  description: String
  model: String
  category: CategoryUpdateOneWithoutEquipmentInput
  diagnostics: DiagnosticProcedureUpdateManyWithoutEquipmentInput
}

input EquipmentUpdateWithoutCategoryDataInput {
  name: String
  description: String
  model: String
  diagnostics: DiagnosticProcedureUpdateManyWithoutEquipmentInput
  assets: AssetUpdateManyWithoutEquipmentInput
}

input EquipmentUpdateWithoutDiagnosticsDataInput {
  name: String
  description: String
  model: String
  category: CategoryUpdateOneWithoutEquipmentInput
  assets: AssetUpdateManyWithoutEquipmentInput
}

input EquipmentUpdateWithWhereUniqueWithoutCategoryInput {
  where: EquipmentWhereUniqueInput!
  data: EquipmentUpdateWithoutCategoryDataInput!
}

input EquipmentUpsertWithoutAssetsInput {
  update: EquipmentUpdateWithoutAssetsDataInput!
  create: EquipmentCreateWithoutAssetsInput!
}

input EquipmentUpsertWithoutDiagnosticsInput {
  update: EquipmentUpdateWithoutDiagnosticsDataInput!
  create: EquipmentCreateWithoutDiagnosticsInput!
}

input EquipmentUpsertWithWhereUniqueWithoutCategoryInput {
  where: EquipmentWhereUniqueInput!
  update: EquipmentUpdateWithoutCategoryDataInput!
  create: EquipmentCreateWithoutCategoryInput!
}

input EquipmentWhereInput {
  """Logical AND on all given filters."""
  AND: [EquipmentWhereInput!]

  """Logical OR on all given filters."""
  OR: [EquipmentWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [EquipmentWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  description: String

  """All values that are not equal to given value."""
  description_not: String

  """All values that are contained in given list."""
  description_in: [String!]

  """All values that are not contained in given list."""
  description_not_in: [String!]

  """All values less than the given value."""
  description_lt: String

  """All values less than or equal the given value."""
  description_lte: String

  """All values greater than the given value."""
  description_gt: String

  """All values greater than or equal the given value."""
  description_gte: String

  """All values containing the given string."""
  description_contains: String

  """All values not containing the given string."""
  description_not_contains: String

  """All values starting with the given string."""
  description_starts_with: String

  """All values not starting with the given string."""
  description_not_starts_with: String

  """All values ending with the given string."""
  description_ends_with: String

  """All values not ending with the given string."""
  description_not_ends_with: String
  model: String

  """All values that are not equal to given value."""
  model_not: String

  """All values that are contained in given list."""
  model_in: [String!]

  """All values that are not contained in given list."""
  model_not_in: [String!]

  """All values less than the given value."""
  model_lt: String

  """All values less than or equal the given value."""
  model_lte: String

  """All values greater than the given value."""
  model_gt: String

  """All values greater than or equal the given value."""
  model_gte: String

  """All values containing the given string."""
  model_contains: String

  """All values not containing the given string."""
  model_not_contains: String

  """All values starting with the given string."""
  model_starts_with: String

  """All values not starting with the given string."""
  model_not_starts_with: String

  """All values ending with the given string."""
  model_ends_with: String

  """All values not ending with the given string."""
  model_not_ends_with: String
  category: CategoryWhereInput
  diagnostics_every: DiagnosticProcedureWhereInput
  diagnostics_some: DiagnosticProcedureWhereInput
  diagnostics_none: DiagnosticProcedureWhereInput
  assets_every: AssetWhereInput
  assets_some: AssetWhereInput
  assets_none: AssetWhereInput
}

input EquipmentWhereUniqueInput {
  id: ID
}

type Location implements Node {
  id: ID!
  name: String!
  address: String!
  assets(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Asset!]
  customer(where: CustomerWhereInput): Customer!
  notes(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Note!]
}

"""A connection to a list of items."""
type LocationConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  name: String!
  address: String!
  assets: AssetCreateManyWithoutLocationInput
  customer: CustomerCreateOneWithoutLocationsInput!
  notes: NoteCreateManyInput
}

input LocationCreateManyWithoutCustomerInput {
  create: [LocationCreateWithoutCustomerInput!]
  connect: [LocationWhereUniqueInput!]
}

input LocationCreateOneWithoutAssetsInput {
  create: LocationCreateWithoutAssetsInput
  connect: LocationWhereUniqueInput
}

input LocationCreateWithoutAssetsInput {
  name: String!
  address: String!
  customer: CustomerCreateOneWithoutLocationsInput!
  notes: NoteCreateManyInput
}

input LocationCreateWithoutCustomerInput {
  name: String!
  address: String!
  assets: AssetCreateManyWithoutLocationInput
  notes: NoteCreateManyInput
}

"""An edge in a connection."""
type LocationEdge {
  """The item at the end of the edge."""
  node: Location!

  """A cursor for use in pagination."""
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  address_ASC
  address_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type LocationPreviousValues {
  id: ID!
  name: String!
  address: String!
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [LocationSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [LocationSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [LocationSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
}

input LocationUpdateInput {
  name: String
  address: String
  assets: AssetUpdateManyWithoutLocationInput
  customer: CustomerUpdateOneWithoutLocationsInput
  notes: NoteUpdateManyInput
}

input LocationUpdateManyWithoutCustomerInput {
  create: [LocationCreateWithoutCustomerInput!]
  connect: [LocationWhereUniqueInput!]
  disconnect: [LocationWhereUniqueInput!]
  delete: [LocationWhereUniqueInput!]
  update: [LocationUpdateWithWhereUniqueWithoutCustomerInput!]
  upsert: [LocationUpsertWithWhereUniqueWithoutCustomerInput!]
}

input LocationUpdateOneWithoutAssetsInput {
  create: LocationCreateWithoutAssetsInput
  connect: LocationWhereUniqueInput
  delete: Boolean
  update: LocationUpdateWithoutAssetsDataInput
  upsert: LocationUpsertWithoutAssetsInput
}

input LocationUpdateWithoutAssetsDataInput {
  name: String
  address: String
  customer: CustomerUpdateOneWithoutLocationsInput
  notes: NoteUpdateManyInput
}

input LocationUpdateWithoutCustomerDataInput {
  name: String
  address: String
  assets: AssetUpdateManyWithoutLocationInput
  notes: NoteUpdateManyInput
}

input LocationUpdateWithWhereUniqueWithoutCustomerInput {
  where: LocationWhereUniqueInput!
  data: LocationUpdateWithoutCustomerDataInput!
}

input LocationUpsertWithoutAssetsInput {
  update: LocationUpdateWithoutAssetsDataInput!
  create: LocationCreateWithoutAssetsInput!
}

input LocationUpsertWithWhereUniqueWithoutCustomerInput {
  where: LocationWhereUniqueInput!
  update: LocationUpdateWithoutCustomerDataInput!
  create: LocationCreateWithoutCustomerInput!
}

input LocationWhereInput {
  """Logical AND on all given filters."""
  AND: [LocationWhereInput!]

  """Logical OR on all given filters."""
  OR: [LocationWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [LocationWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  address: String

  """All values that are not equal to given value."""
  address_not: String

  """All values that are contained in given list."""
  address_in: [String!]

  """All values that are not contained in given list."""
  address_not_in: [String!]

  """All values less than the given value."""
  address_lt: String

  """All values less than or equal the given value."""
  address_lte: String

  """All values greater than the given value."""
  address_gt: String

  """All values greater than or equal the given value."""
  address_gte: String

  """All values containing the given string."""
  address_contains: String

  """All values not containing the given string."""
  address_not_contains: String

  """All values starting with the given string."""
  address_starts_with: String

  """All values not starting with the given string."""
  address_not_starts_with: String

  """All values ending with the given string."""
  address_ends_with: String

  """All values not ending with the given string."""
  address_not_ends_with: String
  assets_every: AssetWhereInput
  assets_some: AssetWhereInput
  assets_none: AssetWhereInput
  customer: CustomerWhereInput
  notes_every: NoteWhereInput
  notes_some: NoteWhereInput
  notes_none: NoteWhereInput
}

input LocationWhereUniqueInput {
  id: ID
}

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

type Mutation {
  createCategory(data: CategoryCreateInput!): Category!
  createEquipment(data: EquipmentCreateInput!): Equipment!
  createAsset(data: AssetCreateInput!): Asset!
  createCustomer(data: CustomerCreateInput!): Customer!
  createLocation(data: LocationCreateInput!): Location!
  createDiagnosticProcedure(data: DiagnosticProcedureCreateInput!): DiagnosticProcedure!
  createUserGroup(data: UserGroupCreateInput!): UserGroup!
  createUser(data: UserCreateInput!): User!
  createDiagnosticNode(data: DiagnosticNodeCreateInput!): DiagnosticNode!
  createNote(data: NoteCreateInput!): Note!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateEquipment(data: EquipmentUpdateInput!, where: EquipmentWhereUniqueInput!): Equipment
  updateAsset(data: AssetUpdateInput!, where: AssetWhereUniqueInput!): Asset
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateDiagnosticProcedure(data: DiagnosticProcedureUpdateInput!, where: DiagnosticProcedureWhereUniqueInput!): DiagnosticProcedure
  updateUserGroup(data: UserGroupUpdateInput!, where: UserGroupWhereUniqueInput!): UserGroup
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateDiagnosticNode(data: DiagnosticNodeUpdateInput!, where: DiagnosticNodeWhereUniqueInput!): DiagnosticNode
  updateNote(data: NoteUpdateInput!, where: NoteWhereUniqueInput!): Note
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteEquipment(where: EquipmentWhereUniqueInput!): Equipment
  deleteAsset(where: AssetWhereUniqueInput!): Asset
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteDiagnosticProcedure(where: DiagnosticProcedureWhereUniqueInput!): DiagnosticProcedure
  deleteUserGroup(where: UserGroupWhereUniqueInput!): UserGroup
  deleteUser(where: UserWhereUniqueInput!): User
  deleteDiagnosticNode(where: DiagnosticNodeWhereUniqueInput!): DiagnosticNode
  deleteNote(where: NoteWhereUniqueInput!): Note
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  upsertEquipment(where: EquipmentWhereUniqueInput!, create: EquipmentCreateInput!, update: EquipmentUpdateInput!): Equipment!
  upsertAsset(where: AssetWhereUniqueInput!, create: AssetCreateInput!, update: AssetUpdateInput!): Asset!
  upsertCustomer(where: CustomerWhereUniqueInput!, create: CustomerCreateInput!, update: CustomerUpdateInput!): Customer!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  upsertDiagnosticProcedure(where: DiagnosticProcedureWhereUniqueInput!, create: DiagnosticProcedureCreateInput!, update: DiagnosticProcedureUpdateInput!): DiagnosticProcedure!
  upsertUserGroup(where: UserGroupWhereUniqueInput!, create: UserGroupCreateInput!, update: UserGroupUpdateInput!): UserGroup!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  upsertDiagnosticNode(where: DiagnosticNodeWhereUniqueInput!, create: DiagnosticNodeCreateInput!, update: DiagnosticNodeUpdateInput!): DiagnosticNode!
  upsertNote(where: NoteWhereUniqueInput!, create: NoteCreateInput!, update: NoteUpdateInput!): Note!
  updateManyCategories(data: CategoryUpdateInput!, where: CategoryWhereInput): BatchPayload!
  updateManyEquipments(data: EquipmentUpdateInput!, where: EquipmentWhereInput): BatchPayload!
  updateManyAssets(data: AssetUpdateInput!, where: AssetWhereInput): BatchPayload!
  updateManyCustomers(data: CustomerUpdateInput!, where: CustomerWhereInput): BatchPayload!
  updateManyLocations(data: LocationUpdateInput!, where: LocationWhereInput): BatchPayload!
  updateManyDiagnosticProcedures(data: DiagnosticProcedureUpdateInput!, where: DiagnosticProcedureWhereInput): BatchPayload!
  updateManyUserGroups(data: UserGroupUpdateInput!, where: UserGroupWhereInput): BatchPayload!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput): BatchPayload!
  updateManyDiagnosticNodes(data: DiagnosticNodeUpdateInput!, where: DiagnosticNodeWhereInput): BatchPayload!
  updateManyNotes(data: NoteUpdateInput!, where: NoteWhereInput): BatchPayload!
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  deleteManyEquipments(where: EquipmentWhereInput): BatchPayload!
  deleteManyAssets(where: AssetWhereInput): BatchPayload!
  deleteManyCustomers(where: CustomerWhereInput): BatchPayload!
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  deleteManyDiagnosticProcedures(where: DiagnosticProcedureWhereInput): BatchPayload!
  deleteManyUserGroups(where: UserGroupWhereInput): BatchPayload!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deleteManyDiagnosticNodes(where: DiagnosticNodeWhereInput): BatchPayload!
  deleteManyNotes(where: NoteWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

type Note implements Node {
  id: ID!
  createdAt: DateTime!
  createdBy(where: UserWhereInput): User!
  content: String!
  archived: Boolean!
}

"""A connection to a list of items."""
type NoteConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [NoteEdge]!
  aggregate: AggregateNote!
}

input NoteCreateInput {
  content: String!
  archived: Boolean
  createdBy: UserCreateOneWithoutNotesInput!
}

input NoteCreateManyInput {
  create: [NoteCreateInput!]
  connect: [NoteWhereUniqueInput!]
}

input NoteCreateManyWithoutCreatedByInput {
  create: [NoteCreateWithoutCreatedByInput!]
  connect: [NoteWhereUniqueInput!]
}

input NoteCreateWithoutCreatedByInput {
  content: String!
  archived: Boolean
}

"""An edge in a connection."""
type NoteEdge {
  """The item at the end of the edge."""
  node: Note!

  """A cursor for use in pagination."""
  cursor: String!
}

enum NoteOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  content_ASC
  content_DESC
  archived_ASC
  archived_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NotePreviousValues {
  id: ID!
  createdAt: DateTime!
  content: String!
  archived: Boolean!
}

type NoteSubscriptionPayload {
  mutation: MutationType!
  node: Note
  updatedFields: [String!]
  previousValues: NotePreviousValues
}

input NoteSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [NoteSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [NoteSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [NoteSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: NoteWhereInput
}

input NoteUpdateDataInput {
  content: String
  archived: Boolean
  createdBy: UserUpdateOneWithoutNotesInput
}

input NoteUpdateInput {
  content: String
  archived: Boolean
  createdBy: UserUpdateOneWithoutNotesInput
}

input NoteUpdateManyInput {
  create: [NoteCreateInput!]
  connect: [NoteWhereUniqueInput!]
  disconnect: [NoteWhereUniqueInput!]
  delete: [NoteWhereUniqueInput!]
  update: [NoteUpdateWithWhereUniqueNestedInput!]
  upsert: [NoteUpsertWithWhereUniqueNestedInput!]
}

input NoteUpdateManyWithoutCreatedByInput {
  create: [NoteCreateWithoutCreatedByInput!]
  connect: [NoteWhereUniqueInput!]
  disconnect: [NoteWhereUniqueInput!]
  delete: [NoteWhereUniqueInput!]
  update: [NoteUpdateWithWhereUniqueWithoutCreatedByInput!]
  upsert: [NoteUpsertWithWhereUniqueWithoutCreatedByInput!]
}

input NoteUpdateWithoutCreatedByDataInput {
  content: String
  archived: Boolean
}

input NoteUpdateWithWhereUniqueNestedInput {
  where: NoteWhereUniqueInput!
  data: NoteUpdateDataInput!
}

input NoteUpdateWithWhereUniqueWithoutCreatedByInput {
  where: NoteWhereUniqueInput!
  data: NoteUpdateWithoutCreatedByDataInput!
}

input NoteUpsertWithWhereUniqueNestedInput {
  where: NoteWhereUniqueInput!
  update: NoteUpdateDataInput!
  create: NoteCreateInput!
}

input NoteUpsertWithWhereUniqueWithoutCreatedByInput {
  where: NoteWhereUniqueInput!
  update: NoteUpdateWithoutCreatedByDataInput!
  create: NoteCreateWithoutCreatedByInput!
}

input NoteWhereInput {
  """Logical AND on all given filters."""
  AND: [NoteWhereInput!]

  """Logical OR on all given filters."""
  OR: [NoteWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [NoteWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  createdAt: DateTime

  """All values that are not equal to given value."""
  createdAt_not: DateTime

  """All values that are contained in given list."""
  createdAt_in: [DateTime!]

  """All values that are not contained in given list."""
  createdAt_not_in: [DateTime!]

  """All values less than the given value."""
  createdAt_lt: DateTime

  """All values less than or equal the given value."""
  createdAt_lte: DateTime

  """All values greater than the given value."""
  createdAt_gt: DateTime

  """All values greater than or equal the given value."""
  createdAt_gte: DateTime
  content: String

  """All values that are not equal to given value."""
  content_not: String

  """All values that are contained in given list."""
  content_in: [String!]

  """All values that are not contained in given list."""
  content_not_in: [String!]

  """All values less than the given value."""
  content_lt: String

  """All values less than or equal the given value."""
  content_lte: String

  """All values greater than the given value."""
  content_gt: String

  """All values greater than or equal the given value."""
  content_gte: String

  """All values containing the given string."""
  content_contains: String

  """All values not containing the given string."""
  content_not_contains: String

  """All values starting with the given string."""
  content_starts_with: String

  """All values not starting with the given string."""
  content_not_starts_with: String

  """All values ending with the given string."""
  content_ends_with: String

  """All values not ending with the given string."""
  content_not_ends_with: String
  archived: Boolean

  """All values that are not equal to given value."""
  archived_not: Boolean
  createdBy: UserWhereInput
}

input NoteWhereUniqueInput {
  id: ID
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Query {
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  equipments(where: EquipmentWhereInput, orderBy: EquipmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Equipment]!
  assets(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Asset]!
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer]!
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  diagnosticProcedures(where: DiagnosticProcedureWhereInput, orderBy: DiagnosticProcedureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DiagnosticProcedure]!
  userGroups(where: UserGroupWhereInput, orderBy: UserGroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserGroup]!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  diagnosticNodes(where: DiagnosticNodeWhereInput, orderBy: DiagnosticNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DiagnosticNode]!
  notes(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Note]!
  category(where: CategoryWhereUniqueInput!): Category
  equipment(where: EquipmentWhereUniqueInput!): Equipment
  asset(where: AssetWhereUniqueInput!): Asset
  customer(where: CustomerWhereUniqueInput!): Customer
  location(where: LocationWhereUniqueInput!): Location
  diagnosticProcedure(where: DiagnosticProcedureWhereUniqueInput!): DiagnosticProcedure
  userGroup(where: UserGroupWhereUniqueInput!): UserGroup
  user(where: UserWhereUniqueInput!): User
  diagnosticNode(where: DiagnosticNodeWhereUniqueInput!): DiagnosticNode
  note(where: NoteWhereUniqueInput!): Note
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  equipmentsConnection(where: EquipmentWhereInput, orderBy: EquipmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EquipmentConnection!
  assetsConnection(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AssetConnection!
  customersConnection(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerConnection!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  diagnosticProceduresConnection(where: DiagnosticProcedureWhereInput, orderBy: DiagnosticProcedureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DiagnosticProcedureConnection!
  userGroupsConnection(where: UserGroupWhereInput, orderBy: UserGroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserGroupConnection!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  diagnosticNodesConnection(where: DiagnosticNodeWhereInput, orderBy: DiagnosticNodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DiagnosticNodeConnection!
  notesConnection(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NoteConnection!

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node
}

type Subscription {
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  equipment(where: EquipmentSubscriptionWhereInput): EquipmentSubscriptionPayload
  asset(where: AssetSubscriptionWhereInput): AssetSubscriptionPayload
  customer(where: CustomerSubscriptionWhereInput): CustomerSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  diagnosticProcedure(where: DiagnosticProcedureSubscriptionWhereInput): DiagnosticProcedureSubscriptionPayload
  userGroup(where: UserGroupSubscriptionWhereInput): UserGroupSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  diagnosticNode(where: DiagnosticNodeSubscriptionWhereInput): DiagnosticNodeSubscriptionPayload
  note(where: NoteSubscriptionWhereInput): NoteSubscriptionPayload
}

type User implements Node {
  id: ID!
  name: String!
  email: String!
  password: String!
  notes(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Note!]
  groups(where: UserGroupWhereInput, orderBy: UserGroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserGroup!]
  defaultGroup(where: UserGroupWhereInput): UserGroup
}

"""A connection to a list of items."""
type UserConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  name: String!
  email: String!
  password: String!
  notes: NoteCreateManyWithoutCreatedByInput
  groups: UserGroupCreateManyWithoutUsersInput
  defaultGroup: UserGroupCreateOneInput
}

input UserCreateManyWithoutGroupsInput {
  create: [UserCreateWithoutGroupsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutNotesInput {
  create: UserCreateWithoutNotesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutGroupsInput {
  name: String!
  email: String!
  password: String!
  notes: NoteCreateManyWithoutCreatedByInput
  defaultGroup: UserGroupCreateOneInput
}

input UserCreateWithoutNotesInput {
  name: String!
  email: String!
  password: String!
  groups: UserGroupCreateManyWithoutUsersInput
  defaultGroup: UserGroupCreateOneInput
}

"""An edge in a connection."""
type UserEdge {
  """The item at the end of the edge."""
  node: User!

  """A cursor for use in pagination."""
  cursor: String!
}

type UserGroup implements Node {
  id: ID!
  name: String!
  description: String
  personalGroup: Boolean!
  owner(where: UserWhereInput): User!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  notes(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Note!]
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer!]
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category!]
}

"""A connection to a list of items."""
type UserGroupConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [UserGroupEdge]!
  aggregate: AggregateUserGroup!
}

input UserGroupCreateInput {
  name: String!
  description: String
  personalGroup: Boolean
  owner: UserCreateOneInput!
  users: UserCreateManyWithoutGroupsInput
  notes: NoteCreateManyInput
  customers: CustomerCreateManyWithoutGroupInput
  categories: CategoryCreateManyWithoutGroupInput
}

input UserGroupCreateManyWithoutUsersInput {
  create: [UserGroupCreateWithoutUsersInput!]
  connect: [UserGroupWhereUniqueInput!]
}

input UserGroupCreateOneInput {
  create: UserGroupCreateInput
  connect: UserGroupWhereUniqueInput
}

input UserGroupCreateOneWithoutCategoriesInput {
  create: UserGroupCreateWithoutCategoriesInput
  connect: UserGroupWhereUniqueInput
}

input UserGroupCreateOneWithoutCustomersInput {
  create: UserGroupCreateWithoutCustomersInput
  connect: UserGroupWhereUniqueInput
}

input UserGroupCreateWithoutCategoriesInput {
  name: String!
  description: String
  personalGroup: Boolean
  owner: UserCreateOneInput!
  users: UserCreateManyWithoutGroupsInput
  notes: NoteCreateManyInput
  customers: CustomerCreateManyWithoutGroupInput
}

input UserGroupCreateWithoutCustomersInput {
  name: String!
  description: String
  personalGroup: Boolean
  owner: UserCreateOneInput!
  users: UserCreateManyWithoutGroupsInput
  notes: NoteCreateManyInput
  categories: CategoryCreateManyWithoutGroupInput
}

input UserGroupCreateWithoutUsersInput {
  name: String!
  description: String
  personalGroup: Boolean
  owner: UserCreateOneInput!
  notes: NoteCreateManyInput
  customers: CustomerCreateManyWithoutGroupInput
  categories: CategoryCreateManyWithoutGroupInput
}

"""An edge in a connection."""
type UserGroupEdge {
  """The item at the end of the edge."""
  node: UserGroup!

  """A cursor for use in pagination."""
  cursor: String!
}

enum UserGroupOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  personalGroup_ASC
  personalGroup_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserGroupPreviousValues {
  id: ID!
  name: String!
  description: String
  personalGroup: Boolean!
}

type UserGroupSubscriptionPayload {
  mutation: MutationType!
  node: UserGroup
  updatedFields: [String!]
  previousValues: UserGroupPreviousValues
}

input UserGroupSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [UserGroupSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [UserGroupSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [UserGroupSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: UserGroupWhereInput
}

input UserGroupUpdateDataInput {
  name: String
  description: String
  personalGroup: Boolean
  owner: UserUpdateOneInput
  users: UserUpdateManyWithoutGroupsInput
  notes: NoteUpdateManyInput
  customers: CustomerUpdateManyWithoutGroupInput
  categories: CategoryUpdateManyWithoutGroupInput
}

input UserGroupUpdateInput {
  name: String
  description: String
  personalGroup: Boolean
  owner: UserUpdateOneInput
  users: UserUpdateManyWithoutGroupsInput
  notes: NoteUpdateManyInput
  customers: CustomerUpdateManyWithoutGroupInput
  categories: CategoryUpdateManyWithoutGroupInput
}

input UserGroupUpdateManyWithoutUsersInput {
  create: [UserGroupCreateWithoutUsersInput!]
  connect: [UserGroupWhereUniqueInput!]
  disconnect: [UserGroupWhereUniqueInput!]
  delete: [UserGroupWhereUniqueInput!]
  update: [UserGroupUpdateWithWhereUniqueWithoutUsersInput!]
  upsert: [UserGroupUpsertWithWhereUniqueWithoutUsersInput!]
}

input UserGroupUpdateOneInput {
  create: UserGroupCreateInput
  connect: UserGroupWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: UserGroupUpdateDataInput
  upsert: UserGroupUpsertNestedInput
}

input UserGroupUpdateOneWithoutCategoriesInput {
  create: UserGroupCreateWithoutCategoriesInput
  connect: UserGroupWhereUniqueInput
  delete: Boolean
  update: UserGroupUpdateWithoutCategoriesDataInput
  upsert: UserGroupUpsertWithoutCategoriesInput
}

input UserGroupUpdateOneWithoutCustomersInput {
  create: UserGroupCreateWithoutCustomersInput
  connect: UserGroupWhereUniqueInput
  delete: Boolean
  update: UserGroupUpdateWithoutCustomersDataInput
  upsert: UserGroupUpsertWithoutCustomersInput
}

input UserGroupUpdateWithoutCategoriesDataInput {
  name: String
  description: String
  personalGroup: Boolean
  owner: UserUpdateOneInput
  users: UserUpdateManyWithoutGroupsInput
  notes: NoteUpdateManyInput
  customers: CustomerUpdateManyWithoutGroupInput
}

input UserGroupUpdateWithoutCustomersDataInput {
  name: String
  description: String
  personalGroup: Boolean
  owner: UserUpdateOneInput
  users: UserUpdateManyWithoutGroupsInput
  notes: NoteUpdateManyInput
  categories: CategoryUpdateManyWithoutGroupInput
}

input UserGroupUpdateWithoutUsersDataInput {
  name: String
  description: String
  personalGroup: Boolean
  owner: UserUpdateOneInput
  notes: NoteUpdateManyInput
  customers: CustomerUpdateManyWithoutGroupInput
  categories: CategoryUpdateManyWithoutGroupInput
}

input UserGroupUpdateWithWhereUniqueWithoutUsersInput {
  where: UserGroupWhereUniqueInput!
  data: UserGroupUpdateWithoutUsersDataInput!
}

input UserGroupUpsertNestedInput {
  update: UserGroupUpdateDataInput!
  create: UserGroupCreateInput!
}

input UserGroupUpsertWithoutCategoriesInput {
  update: UserGroupUpdateWithoutCategoriesDataInput!
  create: UserGroupCreateWithoutCategoriesInput!
}

input UserGroupUpsertWithoutCustomersInput {
  update: UserGroupUpdateWithoutCustomersDataInput!
  create: UserGroupCreateWithoutCustomersInput!
}

input UserGroupUpsertWithWhereUniqueWithoutUsersInput {
  where: UserGroupWhereUniqueInput!
  update: UserGroupUpdateWithoutUsersDataInput!
  create: UserGroupCreateWithoutUsersInput!
}

input UserGroupWhereInput {
  """Logical AND on all given filters."""
  AND: [UserGroupWhereInput!]

  """Logical OR on all given filters."""
  OR: [UserGroupWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [UserGroupWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  description: String

  """All values that are not equal to given value."""
  description_not: String

  """All values that are contained in given list."""
  description_in: [String!]

  """All values that are not contained in given list."""
  description_not_in: [String!]

  """All values less than the given value."""
  description_lt: String

  """All values less than or equal the given value."""
  description_lte: String

  """All values greater than the given value."""
  description_gt: String

  """All values greater than or equal the given value."""
  description_gte: String

  """All values containing the given string."""
  description_contains: String

  """All values not containing the given string."""
  description_not_contains: String

  """All values starting with the given string."""
  description_starts_with: String

  """All values not starting with the given string."""
  description_not_starts_with: String

  """All values ending with the given string."""
  description_ends_with: String

  """All values not ending with the given string."""
  description_not_ends_with: String
  personalGroup: Boolean

  """All values that are not equal to given value."""
  personalGroup_not: Boolean
  owner: UserWhereInput
  users_every: UserWhereInput
  users_some: UserWhereInput
  users_none: UserWhereInput
  notes_every: NoteWhereInput
  notes_some: NoteWhereInput
  notes_none: NoteWhereInput
  customers_every: CustomerWhereInput
  customers_some: CustomerWhereInput
  customers_none: CustomerWhereInput
  categories_every: CategoryWhereInput
  categories_some: CategoryWhereInput
  categories_none: CategoryWhereInput
}

input UserGroupWhereUniqueInput {
  id: ID
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [UserSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [UserSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [UserSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: UserWhereInput
}

input UserUpdateDataInput {
  name: String
  email: String
  password: String
  notes: NoteUpdateManyWithoutCreatedByInput
  groups: UserGroupUpdateManyWithoutUsersInput
  defaultGroup: UserGroupUpdateOneInput
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  notes: NoteUpdateManyWithoutCreatedByInput
  groups: UserGroupUpdateManyWithoutUsersInput
  defaultGroup: UserGroupUpdateOneInput
}

input UserUpdateManyWithoutGroupsInput {
  create: [UserCreateWithoutGroupsInput!]
  connect: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  delete: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutGroupsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutGroupsInput!]
}

input UserUpdateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
  delete: Boolean
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
}

input UserUpdateOneWithoutNotesInput {
  create: UserCreateWithoutNotesInput
  connect: UserWhereUniqueInput
  delete: Boolean
  update: UserUpdateWithoutNotesDataInput
  upsert: UserUpsertWithoutNotesInput
}

input UserUpdateWithoutGroupsDataInput {
  name: String
  email: String
  password: String
  notes: NoteUpdateManyWithoutCreatedByInput
  defaultGroup: UserGroupUpdateOneInput
}

input UserUpdateWithoutNotesDataInput {
  name: String
  email: String
  password: String
  groups: UserGroupUpdateManyWithoutUsersInput
  defaultGroup: UserGroupUpdateOneInput
}

input UserUpdateWithWhereUniqueWithoutGroupsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutGroupsDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutNotesInput {
  update: UserUpdateWithoutNotesDataInput!
  create: UserCreateWithoutNotesInput!
}

input UserUpsertWithWhereUniqueWithoutGroupsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutGroupsDataInput!
  create: UserCreateWithoutGroupsInput!
}

input UserWhereInput {
  """Logical AND on all given filters."""
  AND: [UserWhereInput!]

  """Logical OR on all given filters."""
  OR: [UserWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [UserWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
  email: String

  """All values that are not equal to given value."""
  email_not: String

  """All values that are contained in given list."""
  email_in: [String!]

  """All values that are not contained in given list."""
  email_not_in: [String!]

  """All values less than the given value."""
  email_lt: String

  """All values less than or equal the given value."""
  email_lte: String

  """All values greater than the given value."""
  email_gt: String

  """All values greater than or equal the given value."""
  email_gte: String

  """All values containing the given string."""
  email_contains: String

  """All values not containing the given string."""
  email_not_contains: String

  """All values starting with the given string."""
  email_starts_with: String

  """All values not starting with the given string."""
  email_not_starts_with: String

  """All values ending with the given string."""
  email_ends_with: String

  """All values not ending with the given string."""
  email_not_ends_with: String
  password: String

  """All values that are not equal to given value."""
  password_not: String

  """All values that are contained in given list."""
  password_in: [String!]

  """All values that are not contained in given list."""
  password_not_in: [String!]

  """All values less than the given value."""
  password_lt: String

  """All values less than or equal the given value."""
  password_lte: String

  """All values greater than the given value."""
  password_gt: String

  """All values greater than or equal the given value."""
  password_gte: String

  """All values containing the given string."""
  password_contains: String

  """All values not containing the given string."""
  password_not_contains: String

  """All values starting with the given string."""
  password_starts_with: String

  """All values not starting with the given string."""
  password_not_starts_with: String

  """All values ending with the given string."""
  password_ends_with: String

  """All values not ending with the given string."""
  password_not_ends_with: String
  notes_every: NoteWhereInput
  notes_some: NoteWhereInput
  notes_none: NoteWhereInput
  groups_every: UserGroupWhereInput
  groups_some: UserGroupWhereInput
  groups_none: UserGroupWhereInput
  defaultGroup: UserGroupWhereInput
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
